---
layout: post
title: Implementation of the Reaction Diffusion Simulation
tags:
- C#
- Silverlight
- Software
status: publish
type: post
published: false
meta:
  dsq_thread_id: '268619487'
---
[singlepic=65,96,left]<em>Update - This post was written before the release of <a href="http://silverlight.net/getstarted/silverlight3/default.aspx" target="_new">Silverlight 3.0b</a>, which provides a number of enhancements relevant to this implementation, such as a WriteableBitmap and Pixel Shaders</em>
<h3>Rendering</h3>
The first obstacle to implementing the <a href="http://www.planetmarshall.co.uk/index.php/2009/03/reaction-diffusion-models/">RD simulation</a> is that Silverlight 2.0 does not by default provide a means of generating dynamic images. WPF has a WriteableBitmap, but no equivalent exists in Silverlight. However, it does support PNG streams so we can dynamically update a bitmap by encoding it to PNG on the fly. For this I have used <a href="http://blogs.msdn.com/jstegman/default.aspx">Joe Stegman's</a> <a href="http://blogs.msdn.com/jstegman/archive/2008/10/27/silverlight-2-sample-updates.aspx">PNGEncoder </a>class, which I have modified slightly to deal with RGB data and to reduce memory usage.
<!--more-->
<h3>Performance notes</h3>
[singlepic=69,96,right]Performance of the simulator is dominated by the time it takes to update the arrays containing the concentration values of the chemicals. Actual rendering time is negligible, even though the image has to be dynamically encoded to a PNG file in order for Silverlight to display it. There are two ways of implementing 2D arrays in Silverlight with C#, rectangular arrays or C style jagged arrays. If this were a desktop application, the most performant method would be to use rectangular arrays and unsafe access, however that option is not available to us in Silverlight so it turns out that, for safe access, jagged arrays are faster.

For example, originally the simulation step looked like this
<pre title="Rectangular array implementation" lang="csharp">for (int j = 0; j &lt; H; j++)
{
 int jm = j != 0 ? j - 1 : H - 1;
 int jp = j != H - 1 ? j + 1 : 0;
 for (int i = 0; i &lt; W; i++)
 {
  int im = i != 0 ? i - 1 : W - 1;
  int ip = i != W - 1 ? i + 1 : 0;
  double d2u = U[j,im]+U[j,ip]+U[jm,i]+U[jp,i]-4*U[j,i];
  double d2v = V[j,im]+V[j,ip]+V[jm,i]+V[jp,i]-4*V[j,i];
  double uv2 = U[j,i]*V[j,i]*V[j,i];
  Uu[j,i] = du*d2u-uv2+F+U[j,i]*one_minus_F;
  Vv[j,i] = dv*d2v+uv2+V[j,i]*one_minus_F_minus_k;
 }
}</pre>
On my machine this took on the order of 600ms to perform 100 iterations. Using jagged arrays instead, we have the following
<pre title="Jagged array implementation" lang="csharp">for (int j = 0; j &lt; H; j++)
{
 int jm = j != 0 ? j - 1 : H - 1;
 int jp = j != H - 1 ? j + 1 : 0;
 for (int i = 0; i &lt; W; i++)
 {
  int im = i != 0 ? i - 1 : W - 1;
  int ip = i != W - 1 ? i + 1 : 0;
  double d2u = U[j][im]+U[j][ip]+U[jm][i]+U[jp][i]-4*U[j][i];
  double d2v = V[j][im]+V[j][ip]+V[jm][i]+V[jp][i]-4*V[j][i];
  double uv2 = U[j][i]*V[j][i]*V[j][i];
  Uu[j][i] = du*d2u-uv2+ F+U[j][i]*one_minus_F;
  Vv[j][i] = dv*d2v+uv2+V[j][i]*one_minus_F_minus_k;
 }
}</pre>
Just replacing the array type and making no other changes this now takes about 500ms, an improvement of about 13%. However, now that we are using jagged arrays we can do better and move the row accesses out of the inner loop.
<pre title="Jagged array with outer loop caching" lang="csharp">for (int j = 0; j &lt; H; j++)
{
 int jm = j != 0 ? j - 1 : H - 1;
 int jp = j != H - 1 ? j + 1 : 0;
 var u_m = U[jm];
 var u = U[j];
 var u_p = U[jp];
 var v_m = V[jm];
 var v = V[j];
 var v_p = V[jp];
 var uu = Uu[j];
 var vv = Vv[j];
 for (int i = 0; i &lt; W; i++)
 {
  int im = i != 0 ? i - 1 : W - 1;
  int ip = i != W - 1 ? i + 1 : 0;
  double d2u = u[im]+u[ip]+u_m[i]+u_p[i]-4*u[i];
  double d2v = v[im]+v[ip]+v_m[i]+v_p[i]-4*v[i];
  double uv2 = u[i]*v[i] *v[i];
  uu[i] = du*d2u-uv2+F+u[i]*one_minus_F;
  vv[i] = dv*d2v+uv2+v[i]*one_minus_F_minus_k;
 }
}</pre>
This brings the count down to about 330ms, an improvement of about 40% over the original implementation.

We've taken the sequential code about as far as we can go. The next step is to try to take advantage of muliple cores that may be available on the user's machine.

<!--nextpage-->
<h3>Multithreading</h3>
The graph below show the CPU activity on my dual-core machine while running 10000 iterations of the simulation. Clearly there is room for improvement.

[singlepic=54]

The most obvious approach is to do a row-wise data decomposition of the arrays typical of parallel image processing operations. The basic process is the same as that described in this <a href="http://developer.amd.com/documentation/articles/pages/8292006147.aspx" target="_new">article</a> by Larry O'Brien. The code listing is simplified, and only shows how it differs from the single threaded version. In summary, we make use of the following threading primitives:
<ul>
	<li><code>ManualResetEvent</code> provides a means of cross thread communication. It is used here to indicate that a simulation step has completed and is ready for rendering.</li>
	<li><code>Interlocked</code> provides a means of updating and reading a counter in a thread-safe manner, which we use to keep track of the number of blocks remaining to be updated.</li>
	<li><code>ThreadPool</code> is a pool of worker threads managed by the Silverlight runtime.</li>
	<li><code>WaitCallback</code> is the signature for a function that can be executed on a thread from the <code>ThreadPool</code>.</li>
</ul>
<pre lang="csharp">// the ManualResetEvent is used to signal the Main thread
// when a simulation step is done
ManualResetEvent done = new ManualResetEvent(false);
int blocksPlusOne = 1;
WaitCallback rdStepBlock = delegate(object state)
{
 int[] range= (int[])state;
 for (int j = range[0]; j &lt; range[1]; j++)
 {
   // process block as per single threaded code

  // if this is the last block unblock the thread
  int isDone = Interlocked.Decrement(ref blocksPlusOne );
  if (isDone == 0)  {  done.Set(); }
};

for (int b = 0; b &lt; NumBlocks; b++)
{
 int min = rowsPerBlock * b;
 int max = min + rowsPerBlock;
 Interlocked.Increment(ref blocksPlusOne );
 ThreadPool.QueueUserWorkItem(rdStepBlock, new int[] { min, max });
}
int isDoneAlt = Interlocked.Decrement(ref blocksPlusOne );
if (isDoneAlt == 0) { done.Set(); }

// block until done
done.WaitOne();</pre>
This graph below shows the CPU activity for this method, indicating that both cpu cores are saturated. This reduces the time for ten iterations to about 220ms. Note that the use of cross thread communication reduces the amount of code that can actually be executed in parallel, so one of the goals of parallel programming is to reduce the need for such primitives as much as possible. However, at this point the simulation is fast enough for our purposes.
[singlepic=55]
<h3>Image Generation</h3>
One useful feature is the ability to generate a high resolution PNG that can be saved to the user's computer. To do this, we generate a base64 encoding of the PNG stream and embed it inline in a new web page using the <a href="http://en.wikipedia.org/wiki/Data_URI_scheme" target="_new">data URI scheme</a>. Unfortunately, currently only Firefox appears to support streams of the required length.
