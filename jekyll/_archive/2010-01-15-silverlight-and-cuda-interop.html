---
layout: post
title: Silverlight and CUDA interop
tags:
- C#
- CUDA
- Silverlight
- Software
status: publish
type: post
published: false
meta:
  dsq_thread_id: '268619511'
  _syntaxhighlighter_encoded: '1'
  _edit_last: '2'
---
[singlepic id=78 h=96 float=right]
<em>Update - <a href="#source">source code</a> now available</em>
<p class="pm_first">Microsoft have recently released a beta of Silverlight 4, which has limited support for native interoperation using COM. Potentially, this example could be applied to any number of native interop scenarios, however for this example I have chosen to use Nvidia's CUDA technology.</p>

<blockquote>Disclaimer : This is an example of what can be done, not necessarily, and in all likelihood, an example of how it should be done.</blockquote>
<h3>About CUDA</h3>
Up until around 2001 PC graphics cards, though powerful, implemented a fixed function pipeline that limited use to whatever was exposed by the APIs, usually Direct3D or OpenGL. The addition of a programmable pixel pipeline led to the use of graphics cards for more general computation tasks; at first using shaders directly, followed by higher level GPU specific programming languages, such as Brook, SH, and later NVidia's CUDA. Most of this work was, and is, documented by the <a title="GPGPU" href="http://gpgpu.org/" target="_blank">GPGPU</a> group. <a href="http://www.nvidia.com/object/cuda_home.html#" target="_blank">NVIDIA's website</a> shows CUDA being used in a wide variety of applications but in practice it is best employed in so called "<a title="Wikipedia : Embarrassingly Parallel" href="http://en.wikipedia.org/wiki/Embarrassingly_parallel" target="_blank">embarassingly parallel</a>" problems.
<!--more-->
<h3>The demonstration application</h3>
The demo below shows a Silverlight 4 beta application, which implements a recursive gaussian filter. Note that this is not the same algorithm provided by the sample in the CUDA SDK, but a more efficient method, which is described in detail in <a href="#young">[1]</a> for those interested. The main advantage of a filter implemented in this way is that the computation time is independent of the width of the filter.
To enable CUDA interop, you'll need a CUDA compatible graphics card. Then do the following,
<ol>
	<li>Install the MFC COM application (link below). The installer should register the application with COM automatically.</li>
	<li>Right click on the Silverlight App and install it for running outside of the browser. The CUDA option should now be available from the Combo box.</li>
</ol>
Source code : <a title="Download source code" href="http://planetmarshall.co.uk/silverlight/cuda_interop/SilverlightCudaInteropDemo.zip" name="source">SilverlightCudaInteropDemo.zip</a>
<a title="Install CUDA Server application" href="http://planetmarshall.co.uk/silverlight/cuda_interop/CudaServer.msi">Install MFC COM Application (5.5 Mb)</a>
[silverlight: cuda_interop/SlCudaInteropDemo.xap,520,580,false]
<h3>The native component</h3>
The native component takes the form of a COM Automation server, implemented as a client side MFC application.
<blockquote>Note: Make sure you run Visual Studio with Administrator privileges, otherwise registering the automation server with COM will fail.</blockquote>
MFC and Automation are beyond the scope of this article, but the basic process I followed was thus
<ol>
	<li>Create an MFC Dialog application using the Wizard. Make sure to enable Automation support</li>
	<li>Add a method to the autmation interface using the add Method wizard from the Class View</li>
	<li>Add a dual interface using this <a title="TN065: Dual-Interface Support for OLE Automation Servers" href="http://msdn.microsoft.com/en-us/library/4h56szat%28VS.100%29.aspx" target="_blank">Technical Note</a> from MSDN.</li>
	<li>If you get link errors, make sure to include the output of MIDL in the application class ( the one that contains OnInitInstance). I couldn't find any reference to this step, but it's how the samples work.</li>
	<li>Make sure that the run time library options passed to nvcc and msvc match, ie they should all use a DLL or Static linking, not a mixture of both</li>
	<li>If you get stuck, take a look at the <a title="MFC Samples" href="http://msdn.microsoft.com/en-us/library/482ck6x8%28VS.100%29.aspx" target="_blank">MFC Samples</a>, particularly <a title="ACDUAL Sample: Adds Dual Interfaces to an Automation Application" href="http://msdn.microsoft.com/en-us/library/xfx55tf8%28VS.100%29.aspx" target="_blank">acdual</a>.</li>
</ol>
when you pass a native array through COM Automation, it is converted to a <a title="Array Manipulation Functions from MSDN" href="http://msdn.microsoft.com/en-us/library/ms221145%28VS.100%29.aspx" target="_blank"><code>SAFEARRAY</code></a> on the native side. Note that I couldn't find any documentation on this, I discovered it through experience. The code snippets below show sending and receiving array data between Silverlight and the MFC application.
[csharp]
// note that ComAutomationFactory has become AutomationFactory
// in Silverlight 4 RC
dynamic cuda = AutomationFactory.CreateObject(&quot;CudaServer.Application&quot;);
float[] data = new [] {1.0f, 3.14f };
dynamic retData = cuda.Process( data );
// retData is a managed float array
[/csharp]
[cpp]
VARIANT CCudaServer::Process(VARIANT &amp;amp;data)
{
  SAFEARRAY *pSrcData =  data.parray;

  // this will copy the safe array into the variant
  CComVariant var(pSrcData);

  // when we return the VARIANT containing the SAFEARRAY
  // it will be marshaled to Silverlight as a managed array
  VARIANT retVal;
  VariantInit( &amp;amp;retVal );
  var.Detach( &amp;amp;retVal );
  retVal.vt = VT_ARRAY | VT_R4;
  return retVal;
}
[/cpp]
<h3>Using MEF to implement the application</h3>
The <a title="Managed Extensibility Framework at Codeplex" href="http://www.codeplex.com/MEF" target="_blank">Managed Extensibility Framework</a> is an extensible plugin framework for .NET applications and Silverlight. I have used it to dynamically discover implementations of <code>IProcessorProvider</code> based on the permissions available to the Silverlight application. The figure below shows the component structure of the application.

[singlepic id=77 w=475 template=figure]
<h3>Performance notes</h3>
<h4>Silverlight</h4>
Unlike the <a title="My Reaction-Diffusion simulator" href="http://www.planetmarshall.co.uk/index.php/2009/03/reaction-diffusion-models/">Reaction Diffusion simulation</a>, for this application I have chosen to use Silverlight's <a title="WirteableBitmap in Silverlight 3, from MSDN" href="http://msdn.microsoft.com/en-us/library/system.windows.media.imaging.writeablebitmap%28VS.95%29.aspx" target="_blank"><code>WriteableBitmap</code></a>, introduced in Silverlight 3, rather than <a title="Joe Stegman's PNG Encoder for Silverlight" href="http://blogs.msdn.com/jstegman/archive/2008/04/21/dynamic-image-generation-in-silverlight.aspx" target="_blank">dynamic PNG encoding</a>. This revealed an interesting performance issue when using a typical double loop to iterate over the pixels. Initial timings revealed that the vast majority of the time was spent in updating the <code>WriteableBitmap</code> rather than actually performing the image processing. The initial update loop used the <code>PixelWidth</code> and <code>PixelHeight</code> properties to bound the loop counters, taking about 200ms to iterate over the loop.
[csharp]
for (int j = 0; j &amp;lt; bmp.PixelHeight; ++j)
{
  for (int i = 0; i &amp;lt; bmp.PixelWidth; ++i)
  {
     // update pixels
   }
}
[/csharp]
By caching the bitmap properties in local variables, the timing was reduced to ~5ms. Needless to say I was shocked by how much of a difference such a seemingly trivial change made.
[csharp]
int pxWidth =Â  bmp.PixelWidth;
int pxHeight = bmp.PixelHeight;
for (int j = 0; j &amp;lt; pxHeight; ++j)
{
  for (int i = 0; i &amp;lt; pxWidth; ++i)
  {
     // update pixels
   }
}
[/csharp]
<h4>OLE Automation</h4>
The guidelines for building performant automation code is much the same as that for other unmanaged interop scenarios in .NET : avoid chatty interfaces. Note that this is exactly what I have not done here. In fact, the time it takes CUDA to perform the image processing is dwarfed by the time it takes to marshal the data between Silverlight and COM. This can be mitigated somewhat by splitting the blur call into two operations, one to load the image, which is called only upon initialization, and one to perform the blur.
<h4>CUDA</h4>
CUDA operations are extremely sensitive to data alignment and the order in which threads access data. Kernels should be written in such a way that threads access adjacent data elements, meaning that the row major access pattern familiar to C and C# developers would produce suboptimal performance ( sometimes by as much as an order of magnitude ). Instead, array accesses should be performed in a manner more reminiscent of FORTRAN. In addition, 2D arrays should be padded out so that threads access data elements that are correctly aligned ( see the CUDA documentation for the correct alignment values ). A full exposition of performance optimization for CUDA is really beyond the scope of this article, there are many examples in the <a title="Learn More about CUDA - NVIDIA" href="http://www.nvidia.com/object/cuda_education.html" target="_blank">NVIDIA documentation</a> although the terminology can be somewhat opaque. One of the clearest explanations I have found is this <a title="Supercomputing 2007 CUDA Tutorial" href="http://gpgpu.org/sc2007" target="_blank">presentation </a>from Mark Harris at Supercomputing 2007.
[cpp]
__global__ void kernel( float *destData, float *srcData, int stride, int height )
{
  // suboptimal access. Each thread accesses elements
 // in a striding pattern
  int rowStart = (blockDim.x*blockIdx.x+threadIdx.x)*stride;
  for ( int i = rowStart; i &amp;lt; rowStart+stride; ++i ) {
    destData[i] = srcData[i];
  }
}
[/cpp]
[cpp]
__global__ void kernel( float *destData, float *srcData, int stride, int height )
{
  // optimal access pattern, each thread accesses adjacent elements
  int colStart = blockDim.x*blockIdx.x+threadIdx.x;
  // this case, 16*sizeof(float)= 64 bytes
  for ( int i = colStart ; i &amp;lt; colStart+(stride*height); i+=stride ) {
    destData[i] = srcData[i];
  }
}
[/cpp]
<h3>References</h3>
<ol>
	<li><span class="p1"><a name="young"></a>Young, I.T. &amp; van Vliet,L.J, 1995. <a title="Recursive Implementation of the Gaussian Filter" href="http://www.sciencedirect.com/science?_ob=ArticleURL&amp;_udi=B6V18-3YS90HC-D&amp;_user=10&amp;_coverDate=06%2F30%2F1995&amp;_rdoc=2&amp;_fmt=high&amp;_orig=browse&amp;_srch=doc-info%28%23toc%235668%231995%23999559997%23172292%23FLP%23display%23Volume%29&amp;_cdi=5668&amp;_sort=d&amp;_docanchor=&amp;_ct=11&amp;_acct=C000050221&amp;_version=1&amp;_urlVersion=0&amp;_userid=10&amp;md5=cdfad44c178fc20739d26562c5f26e04" target="_blank">Recursive implementation of the Gaussian filter</a>. <em>Signal Processing</em>, 44, pp.139-151. </span></li>
</ol>
